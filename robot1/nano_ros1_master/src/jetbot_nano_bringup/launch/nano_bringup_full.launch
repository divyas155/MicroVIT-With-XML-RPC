<launch>
  <!-- FULL Jetson Nano bringup: Motor driver + Sensors + XML-RPC server -->
  <!-- This launch file starts EVERYTHING needed for the robot to move -->
  <!-- Uses Python motor driver (more reliable than C++ jetbot_pro) -->

  <!-- REAL SENSORS ONLY - No dummy/fallback when use_dummy:=false -->
  <!-- Real odometry from motor driver, real LiDAR from rplidarNode, real camera from /dev/video* -->
  <arg name="use_lidar" default="true" />
  <arg name="use_camera" default="true" />
  <arg name="use_odom_dummy" default="false" />
  <arg name="lidar_serial_port" default="/dev/ttyUSB0" />
  <!-- Many RPLidar A1/A2M8 need 115200; try 256000 if yours works at higher baud -->
  <arg name="lidar_serial_baudrate" default="115200" />

  <!-- ========== JETBOT PRO MOTOR DRIVER (Python) ========== -->
  <node pkg="jetbot_nano_bringup"
        type="jetbot_motor_driver.py"
        name="jetbot_motor_driver"
        output="screen"
        respawn="true">
    <param name="port_name" value="/dev/ttyACM0"/>
    <param name="baud_rate" value="115200"/>
    <param name="linear_correction" value="1.0"/>
    <param name="angular_correction" value="1.0"/>
    <param name="cmd_timeout" value="0.5"/>
  </node>

  <!-- ========== SENSOR NODES ========== -->
  
  <!-- REAL LiDAR: rplidarNode when use_lidar:=true. When false, use dummy so /scan is always available. -->
  <node pkg="rplidar_ros" type="rplidarNode" name="rplidarNode" output="screen" respawn="true" if="$(arg use_lidar)">
    <param name="serial_port" type="string" value="$(arg lidar_serial_port)"/>
    <param name="serial_baudrate" type="int" value="$(arg lidar_serial_baudrate)"/>
    <param name="frame_id" type="string" value="laser"/>
    <param name="inverted" type="bool" value="false"/>
    <param name="angle_compensate" type="bool" value="true"/>
    <remap from="scan" to="/scan"/>
  </node>
  <node pkg="jetbot_nano_bringup" type="lidar_dummy_node.py" name="nano_lidar_dummy" output="screen" unless="$(arg use_lidar)">
    <param name="rate" value="5.0"/>
    <param name="frame_id" value="laser"/>
  </node>

  <!-- Odometry: motor driver publishes real /odom. Odom dummy only when use_odom_dummy:=true (simulated when motor has no encoders). -->
  <node pkg="jetbot_nano_bringup" type="odom_dummy_node.py" name="nano_odom_dummy"
        output="screen" respawn="true" if="$(arg use_odom_dummy)">
    <param name="rate" value="10.0"/>
    <param name="frame_id" value="odom"/>
    <param name="base_frame_id" value="base_link"/>
  </node>

  <!-- ========== CAMERA (REAL ONLY - no dummy, respawn=false to avoid storm) ========== -->
  <!-- 320x240 reduces USB load; helps when dmesg shows "Cannot enable. Maybe the USB cable is bad?" -->
  <arg name="camera_device" default="/dev/video0" />
  <arg name="camera_width" default="320" />
  <arg name="camera_height" default="240" />
  <param name="camera_width" value="$(arg camera_width)" />
  <param name="camera_height" value="$(arg camera_height)" />
  <node pkg="jetbot_nano_bringup"
        type="camera_publisher_node.py"
        name="nano_camera_publisher"
        output="screen"
        respawn="false"
        if="$(arg use_camera)">
    <param name="camera_device" value="$(arg camera_device)" />
    <param name="camera_width" value="$(arg camera_width)" />
    <param name="camera_height" value="$(arg camera_height)" />
    <param name="rate" value="5.0" />
  </node>

  <!-- ========== XML-RPC SERVER (gets camera from /nano/camera/image_compressed) ========== -->
  <node pkg="jetbot_nano_bringup"
        type="xmlrpc_server_nano_realtime.py"
        name="nano_xmlrpc_server"
        output="screen"
        respawn="true"
        respawn_delay="3">
  </node>

  <!-- Motor Service Server (backup) -->
  <node pkg="jetbot_nano_bringup"
        type="motor_service_server.py"
        name="nano_motor_service_server"
        output="screen"
        respawn="true"
        respawn_delay="2">
    <param name="wheel_base" value="0.2" />
    <param name="wheel_radius" value="0.03" />
  </node>

  <!-- ========== AUTONOMOUS DRIVER (move when clear, stop when obstacle < threshold) ========== -->
  <!-- front sector only: side/rear obstacles ignored so robot resumes when path ahead is clear -->
  <arg name="use_autonomous" default="true" />
  <arg name="obstacle_threshold" default="0.5" />
  <arg name="forward_sector_deg" default="90" />
  <arg name="forward_angle_offset_deg" default="0" />
  <node pkg="jetbot_nano_bringup"
        type="autonomous_driver_node.py"
        name="autonomous_driver"
        output="screen"
        respawn="true"
        if="$(arg use_autonomous)">
    <param name="obstacle_threshold" value="$(arg obstacle_threshold)" />
    <param name="forward_sector_deg" value="$(arg forward_sector_deg)" />
    <param name="forward_angle_offset_deg" value="$(arg forward_angle_offset_deg)" />
    <param name="forward_speed" value="0.2" />
    <param name="rate" value="10.0" />
  </node>

  <!-- TF: base_footprint to laser -->
  <node pkg="tf" type="static_transform_publisher" name="base_to_laser" 
        args="0.1 0 0.1 0 0 0 base_footprint laser 20"/> 

</launch>
